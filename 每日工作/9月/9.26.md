# 9.26

## 1. 准备面试

### 1. 计网

1. TCP
   1. 三次握手四次挥手，详细
2. HTTP



### 2. 操作系统



### 3. MySQL

#### 索引 √



### 4. Redis

#### 1. 线程模型

redis的命令线程一定是单线程的，Redis添加线程的原因是防止耗时任务降低性能。

1. 在Redis2.6时，Redis添加了两个线程：文件关闭线程和AOF刷盘线程
2. Redis4.0后，Redis添加了一个新的线程：lazyfree线程，用于异步释放Redis内存。使用`del`命令走的是主线程释放，使用`unlink`命令走的是lazyfree线程释放，假如删除一个大key，不走异步可能会导致主线程卡顿。
3. Redis6.0后，为了加速处理网络IO，从原来的单线程+epoll转变为多线程+epoll，而这个多线程只处理IO任务，处理更加频繁的网络连接和请求。

#### 2. 持久化

##### 1. AOF

1. Append On File 顾名思义，就是在AOF文件后面拼接指令，来进行持久化。
2. AOF的时机：
   1. Always：在每次执行完进行
   2. EverySec：每秒执行一次
   3. NO：交由操作系统调度执行时机
3. AOF重写机制：
   1. 当AOF文件到达最大值，将会读取当前db的所有数据，并将每一个键值对用一条命令记录到新AOF文件中，等记录完成后，替换掉旧文件。

##### 2. RDB

1. RDB会记录`某时刻`的数据快照，恢复速度比AOF快，因为AOF还要从文件中执行指令，RDB只需要将RDB文件写入内存即可。
2. RDB生成快照会阻塞主线程吗？
   - Redis提供了两个命令来执行RDB生成：`save`和`bgsave`，前者是直接在主线程上执行的，而后者是fork一个子进程执行。因此，后者可以避免阻塞。

##### 3. 混合持久化（AOF+RDB）

1. 为什么会有混合持久化：

   - 因为RDB的持久化是全量的，因此每次持久化都会进行繁重的快照。

   - AOF的持久化是增量的，但是随着时间增长，AOF文件变得很大时，恢复会消耗大量时间。

2. 混合持久化的机制：
   - 混合持久化工作在 AOF 日志重写过程，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

#### 3. Redis数据结构

##### 1. String



##### 2. Hash

##### 3. Queue

##### 4. Set

##### 5. VSet



#### 4. 缓存设计 （明天看）

##### 1. 缓存击穿

- 场景：用户的某个查询

- 解决方案：

##### 2. 缓存穿透



##### 3. 缓存雪崩



### 5. RabbitMQ

#### 1. 如何防止消息丢失（消息可靠性）

1. 生产者端：本地事务完成和消息发送必须是同步的，通过事务消息完成（如果不同步，可能会出现消息发送失败但是事务成功提交）
2. 生产者->MQ Server：通过confirm机制做逻辑处理确保发送成功，没有收到ack或收到nack则将消息放进重传队列。
3. MQ Server端：为防止宕机导致的消息丢失，开启持久化。
4. 消费者的ack做控制，手动回应

#### 2. 如何防止消息被重复消费

1. 生产者需要保证不重复发送信息：
   1. 接口幂等性，请求不可重复
   2. 生产者的消息发送成功但是mq的confirm丢失，会重传一条消息到mq，此时会出现两条消息在mq。
2. 消费者需要保证不重复消费信息：
   1. 在消息中保存唯一id，使用redis存储消息，如果消息id存在，则不消费。

#### 3. 如何保证消息被顺序消费

1. 单一消费者情况，消息一定是顺序消费的。

   

#### 4. 如何防止消息堆积

- 原因：
  - 消费者消费的慢
  - 消费出现问题导致nack队列太多
- 解决：
  - 消费过程改成异步或多线程(提高消费效率)
  - 将当前业务的topic改成新topic，然后新增多几个消费者在这个新的topic上，保证业务能正常执行，前面堆积的这些单独开些消费者在这里消费。(增加消费者，且不影响业务)

### IO 模型

1. 从文件角度看I/O
   1. bio/nio/aio
2. I/O多路复用 
   1. 实现原理
   2. select/poll/epoll  为什么epoll主流
   3. 为什么不用多线程实现？
      - CPU上下文切换代价高昂
