# 9.26

## 1. 准备面试

### 1. 计网

1. TCP
   1. 三次握手四次挥手，详细
2. HTTP



### 2. 操作系统



### 3. MySQL

#### 索引



### 4. Redis

#### 1. 线程模型

redis的命令线程一定是单线程的，Redis添加线程的原因是防止耗时任务降低性能。

1. 在Redis2.6时，Redis添加了两个线程：文件关闭线程和AOF刷盘线程
2. Redis4.0后，Redis添加了一个新的线程：lazyfree线程，用于异步释放Redis内存。使用`del`命令走的是主线程释放，使用`unlink`命令走的是lazyfree线程释放，假如删除一个大key，不走异步可能会导致主线程卡顿。
3. Redis6.0后，为了加速处理网络IO，从原来的单线程+epoll转变为多线程+epoll，而这个多线程只处理IO任务，处理更加频繁的网络连接和请求。

#### 2. 持久化

1. AOF
   1. 
2. RDB
3. 混合持久化

#### 3. Redis数据结构



#### 4. 缓存设计



### 5. RabbitMQ

#### 1. 如何防止消息丢失（消息可靠性）

1. 生产者端：本地事务完成和消息发送必须是同步的，通过事务消息完成（如果不同步，可能会出现消息发送失败但是事务成功提交）
2. 生产者->MQ Server：通过confirm机制做逻辑处理确保发送成功，没有收到ack或收到nack则将消息放进重传队列。
3. MQ Server端：为防止宕机导致的消息丢失，开启持久化。
4. 消费者的ack做控制，手动回应

#### 2. 如何防止消息被重复消费

1. 生产者需要保证不重复发送信息：
   1. 接口幂等性，请求不可重复
   2. 生产者的消息发送成功但是mq的confirm丢失，会重传一条消息到mq，此时会出现两条消息在mq。
2. 消费者需要保证不重复消费信息：
   1. 在消息中保存唯一id，使用redis存储消息，如果消息id存在，则不消费。

#### 3. 如何保证消息被顺序消费

1. 单一消费者情况，消息一定是顺序消费的。

   

#### 4. 如何防止消息堆积

- 原因：
  - 消费者消费的慢
  - 消费出现问题导致nack队列太多
- 解决：
  - 消费过程改成异步或多线程(提高消费效率)
  - 将当前业务的topic改成新topic，然后新增多几个消费者在这个新的topic上，保证业务能正常执行，前面堆积的这些单独开些消费者在这里消费。(增加消费者，且不影响业务)

